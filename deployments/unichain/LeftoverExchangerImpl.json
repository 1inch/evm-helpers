{
  "address": "0x89314d57A8A4E636A00922ac289BC3a9a69C4361",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IWETH",
          "name": "weth",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "i",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "name": "CallFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ETHTransferFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bool[]",
          "name": "statuses",
          "type": "bool[]"
        },
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "name": "EstimationResults",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ForceApproveFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidLength",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LengthMismatch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotEnoughProfit",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SafeTransferFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "i",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "name": "CallFailure",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "targets",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "arguments",
          "type": "bytes[]"
        }
      ],
      "name": "arbitraryCalls",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "targets",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "arguments",
          "type": "bytes[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        }
      ],
      "name": "arbitraryCalls",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "targets",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "arguments",
          "type": "bytes[]"
        },
        {
          "internalType": "uint256",
          "name": "minReturn",
          "type": "uint256"
        }
      ],
      "name": "arbitraryCallsWithEthCheck",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "targets",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "arguments",
          "type": "bytes[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "minReturn",
          "type": "uint256"
        }
      ],
      "name": "arbitraryCallsWithEthCheck",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "targets",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "arguments",
          "type": "bytes[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minReturn",
          "type": "uint256"
        }
      ],
      "name": "arbitraryCallsWithTokenCheck",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "targets",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "arguments",
          "type": "bytes[]"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minReturn",
          "type": "uint256"
        }
      ],
      "name": "arbitraryCallsWithTokenCheck",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "batchApprove",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "batchTransfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "targets",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "arguments",
          "type": "bytes[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        }
      ],
      "name": "estimateArbitraryCalls",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "targets",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "arguments",
          "type": "bytes[]"
        }
      ],
      "name": "estimateArbitraryCalls",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct LeftoverExchanger.Call[]",
          "name": "calls",
          "type": "tuple[]"
        }
      ],
      "name": "estimateMakeCalls",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "hash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "isValidSignature",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "magicValue",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct LeftoverExchanger.Call[]",
          "name": "calls",
          "type": "tuple[]"
        }
      ],
      "name": "makeCalls",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct LeftoverExchanger.Call[]",
          "name": "calls",
          "type": "tuple[]"
        }
      ],
      "name": "makeCallsNoThrow",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct LeftoverExchanger.Call[]",
          "name": "calls",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "minReturn",
          "type": "uint256"
        }
      ],
      "name": "makeCallsWithEthCheck",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rescueEther",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "unwrapTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x465024a1e8530ccbebb683a03fe0b30bf197159cbd89edb6a044f4ceccf5759b",
  "receipt": {
    "to": null,
    "from": "0x56E44874F624EbDE6efCc783eFD685f0FBDC6dcF",
    "contractAddress": "0x89314d57A8A4E636A00922ac289BC3a9a69C4361",
    "transactionIndex": 10,
    "gasUsed": "1844777",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5ebf3c646fb212e8609babe5bb46643c5b8fb0212a303359045b5b24d29e9b58",
    "transactionHash": "0x465024a1e8530ccbebb683a03fe0b30bf197159cbd89edb6a044f4ceccf5759b",
    "logs": [],
    "blockNumber": 16048491,
    "cumulativeGasUsed": "2794295",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x4200000000000000000000000000000000000006",
    "0x2d2d58933e62ed68794d3c337a4d3bc24809ceb2"
  ],
  "numDeployments": 1,
  "solcInputHash": "cabe460dc7f727bc42a34cd256a091fd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"CallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ETHTransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool[]\",\"name\":\"statuses\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"name\":\"EstimationResults\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForceApproveFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughProfit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"CallFailure\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"arguments\",\"type\":\"bytes[]\"}],\"name\":\"arbitraryCalls\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"arguments\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"arbitraryCalls\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"arguments\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"arbitraryCallsWithEthCheck\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"arguments\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"arbitraryCallsWithEthCheck\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"arguments\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"arbitraryCallsWithTokenCheck\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"arguments\",\"type\":\"bytes[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"arbitraryCallsWithTokenCheck\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"batchApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"arguments\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"estimateArbitraryCalls\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"arguments\",\"type\":\"bytes[]\"}],\"name\":\"estimateArbitraryCalls\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct LeftoverExchanger.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"estimateMakeCalls\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct LeftoverExchanger.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"makeCalls\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct LeftoverExchanger.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"makeCallsNoThrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct LeftoverExchanger.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"makeCallsWithEthCheck\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unwrapTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"isValidSignature(bytes32,bytes)\":{\"details\":\"Should return whether the signature provided is valid for the provided data\",\"params\":{\"hash\":\"Hash of the data to be signed\",\"signature\":\"Signature byte array associated with _data\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"approve(address,address)\":{\"notice\":\"See {IBalanceManager-approve}.\"},\"arbitraryCalls(address[],bytes[])\":{\"notice\":\"See {IBalanceManager-arbitraryCalls}.\"},\"arbitraryCalls(address[],bytes[],uint256[])\":{\"notice\":\"See {IBalanceManager-arbitraryCalls}.\"},\"arbitraryCallsWithEthCheck(address[],bytes[],uint256)\":{\"notice\":\"See {IBalanceManager-arbitraryCallsWithEthCheck}.\"},\"arbitraryCallsWithEthCheck(address[],bytes[],uint256[],uint256)\":{\"notice\":\"See {IBalanceManager-arbitraryCallsWithEthCheck}.\"},\"arbitraryCallsWithTokenCheck(address[],bytes[],address,uint256)\":{\"notice\":\"See {IBalanceManager-arbitraryCallsWithTokenCheck}.\"},\"arbitraryCallsWithTokenCheck(address[],bytes[],uint256[],address,uint256)\":{\"notice\":\"See {IBalanceManager-arbitraryCallsWithTokenCheck}.\"},\"batchApprove(bytes)\":{\"notice\":\"See {IBalanceManager-batchApprove}.\"},\"batchTransfer(bytes)\":{\"notice\":\"See {IBalanceManager-batchTransfer}.\"},\"estimateArbitraryCalls(address[],bytes[])\":{\"notice\":\"See {IBalanceManager-estimateArbitraryCalls}.\"},\"estimateArbitraryCalls(address[],bytes[],uint256[])\":{\"notice\":\"See {IBalanceManager-estimateArbitraryCalls}.\"},\"rescueEther()\":{\"notice\":\"See {IBalanceManager-rescueEther}.\"},\"transfer(address,address,uint256)\":{\"notice\":\"See {IBalanceManager-transfer}.\"},\"unwrapTo(address,uint256)\":{\"notice\":\"See {IBalanceManager-unwrapTo}.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/LeftoverExchanger.sol\":\"LeftoverExchanger\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDaiLikePermit\\n * @dev Interface for Dai-like permit function allowing token spending via signatures.\\n */\\ninterface IDaiLikePermit {\\n    /**\\n     * @notice Approves spending of tokens via off-chain signatures.\\n     * @param holder Token holder's address.\\n     * @param spender Spender's address.\\n     * @param nonce Current nonce of the holder.\\n     * @param expiry Time when the permit expires.\\n     * @param allowed True to allow, false to disallow spending.\\n     * @param v, r, s Signature components.\\n     */\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0xf8636c1c4631641c7b40ac65cd69e6ae04a99cf3358426c642dec02c6c774c82\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IERC7597Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IERC7597Permit\\n * @dev A new extension for ERC-2612 permit, which has already been added to USDC v2.2.\\n */\\ninterface IERC7597Permit {\\n    /**\\n     * @notice Update allowance with a signed permit.\\n     * @dev Signature bytes can be used for both EOA wallets and contract wallets.\\n     * @param owner Token owner's address (Authorizer).\\n     * @param spender Spender's address.\\n     * @param value Amount of allowance.\\n     * @param deadline The time at which the signature expires (unixtime).\\n     * @param signature Unstructured bytes signature signed by an EOA wallet or a contract wallet.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) external;\\n}\\n\",\"keccak256\":\"0xaf148ecd4db0f44989a7417f6945bcfd18273c5096bc2b364e314e42c85c78cd\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IPermit2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPermit2\\n * @dev Interface for a flexible permit system that extends ERC20 tokens to support permits in tokens lacking native permit functionality.\\n */\\ninterface IPermit2 {\\n    /**\\n     * @dev Struct for holding permit details.\\n     * @param token ERC20 token address for which the permit is issued.\\n     * @param amount The maximum amount allowed to spend.\\n     * @param expiration Timestamp until which the permit is valid.\\n     * @param nonce An incrementing value for each signature, unique per owner, token, and spender.\\n     */\\n    struct PermitDetails {\\n        address token;\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    /**\\n     * @dev Struct for a single token allowance permit.\\n     * @param details Permit details including token, amount, expiration, and nonce.\\n     * @param spender Address authorized to spend the tokens.\\n     * @param sigDeadline Deadline for the permit signature, ensuring timeliness of the permit.\\n     */\\n    struct PermitSingle {\\n        PermitDetails details;\\n        address spender;\\n        uint256 sigDeadline;\\n    }\\n\\n    /**\\n     * @dev Struct for packed allowance data to optimize storage.\\n     * @param amount Amount allowed.\\n     * @param expiration Permission expiry timestamp.\\n     * @param nonce Unique incrementing value for tracking allowances.\\n     */\\n    struct PackedAllowance {\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    /**\\n     * @notice Executes a token transfer from one address to another.\\n     * @param user The token owner's address.\\n     * @param spender The address authorized to spend the tokens.\\n     * @param amount The amount of tokens to transfer.\\n     * @param token The address of the token being transferred.\\n     */\\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\\n\\n    /**\\n     * @notice Issues a permit for spending tokens via a signed authorization.\\n     * @param owner The token owner's address.\\n     * @param permitSingle Struct containing the permit details.\\n     * @param signature The signature proving the owner authorized the permit.\\n     */\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    /**\\n     * @notice Retrieves the allowance details between a token owner and spender.\\n     * @param user The token owner's address.\\n     * @param token The token address.\\n     * @param spender The spender's address.\\n     * @return The packed allowance details.\\n     */\\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\\n\\n    /**\\n     * @notice Approves the spender to use up to amount of the specified token up until the expiration\\n     * @param token The token to approve\\n     * @param spender The spender address to approve\\n     * @param amount The approved amount of the token\\n     * @param expiration The timestamp at which the approval is no longer valid\\n     * @dev The packed allowance also holds a nonce, which will stay unchanged in approve\\n     * @dev Setting amount to type(uint160).max sets an unlimited approval\\n     */\\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\\n}\\n\",\"keccak256\":\"0x2ac37c62bb4a4941c1d353df6ac08750542c540234aa24409ac67373651a478a\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title IWETH\\n * @dev Interface for wrapper as WETH-like token.\\n */\\ninterface IWETH is IERC20 {\\n    /**\\n     * @notice Emitted when Ether is deposited to get wrapper tokens.\\n     */\\n    event Deposit(address indexed dst, uint256 wad);\\n\\n    /**\\n     * @notice Emitted when wrapper tokens is withdrawn as Ether.\\n     */\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    /**\\n     * @notice Deposit Ether to get wrapper tokens.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice Withdraw wrapped tokens as Ether.\\n     * @param amount Amount of wrapped tokens to withdraw.\\n     */\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x32989b79850e8a1ac6aab74878de2883f9537656ca06910dc0ae76833cc446e2\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @title ECDSA signature operations\\n * @notice Provides functions for recovering addresses from signatures and verifying signatures, including support for EIP-2098 compact signatures.\\n */\\nlibrary ECDSA {\\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n    // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n    //\\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n    // these malleable signatures as well.\\n    uint256 private constant _S_BOUNDARY = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 + 1;\\n    uint256 private constant _COMPACT_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    uint256 private constant _COMPACT_V_SHIFT = 255;\\n\\n    /**\\n     * @notice Recovers the signer's address from the signature.\\n     * @dev Recovers the address that has signed a hash with `(v, r, s)` signature.\\n     * @param hash The keccak256 hash of the data signed.\\n     * @param v The recovery byte of the signature.\\n     * @param r The first 32 bytes of the signature.\\n     * @param s The second 32 bytes of the signature.\\n     * @return signer The address of the signer.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address signer) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            if lt(s, _S_BOUNDARY) {\\n                let ptr := mload(0x40)\\n\\n                mstore(ptr, hash)\\n                mstore(add(ptr, 0x20), v)\\n                mstore(add(ptr, 0x40), r)\\n                mstore(add(ptr, 0x60), s)\\n                mstore(0, 0)\\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\\n                signer := mload(0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Recovers the signer's address from the signature using `r` and `vs` components.\\n     * @dev Recovers the address that has signed a hash with `r` and `vs`, where `vs` combines `v` and `s`.\\n     * @param hash The keccak256 hash of the data signed.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The combined `v` and `s` values of the signature.\\n     * @return signer The address of the signer.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (address signer) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let s := and(vs, _COMPACT_S_MASK)\\n            if lt(s, _S_BOUNDARY) {\\n                let ptr := mload(0x40)\\n\\n                mstore(ptr, hash)\\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\\n                mstore(add(ptr, 0x40), r)\\n                mstore(add(ptr, 0x60), s)\\n                mstore(0, 0)\\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\\n                signer := mload(0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Recovers the signer's address from a hash and a signature.\\n     * @param hash The keccak256 hash of the signed data.\\n     * @param signature The full signature from which the signer will be recovered.\\n     * @return signer The address of the signer.\\n     */\\n    /// @dev WARNING!!!\\n    /// There is a known signature malleability issue with two representations of signatures!\\n    /// Even though this function is able to verify both standard 65-byte and compact 64-byte EIP-2098 signatures\\n    /// one should never use raw signatures for any kind of invalidation logic in their code.\\n    /// As the standard and compact representations are interchangeable any invalidation logic that relies on\\n    /// signature uniqueness will get rekt.\\n    /// More info: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h\\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address signer) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            // memory[ptr:ptr+0x80] = (hash, v, r, s)\\n            switch signature.length\\n            case 65 {\\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\\n                mstore(add(ptr, 0x20), byte(0, calldataload(add(signature.offset, 0x40))))\\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x40)\\n            }\\n            case 64 {\\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\\n                let vs := calldataload(add(signature.offset, 0x20))\\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x20)\\n                mstore(add(ptr, 0x60), and(vs, _COMPACT_S_MASK))\\n            }\\n            default {\\n                ptr := 0\\n            }\\n\\n            if ptr {\\n                if lt(mload(add(ptr, 0x60)), _S_BOUNDARY) {\\n                    // memory[ptr:ptr+0x20] = (hash)\\n                    mstore(ptr, hash)\\n\\n                    mstore(0, 0)\\n                    pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\\n                    signer := mload(0)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\\n     * @param signer The address to validate the signature against.\\n     * @param hash The hash of the signed data.\\n     * @param signature The signature to verify.\\n     * @return success True if the signature is verified, false otherwise.\\n     */\\n    function recoverOrIsValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool success) {\\n        if (signer == address(0)) return false;\\n        if ((signature.length == 64 || signature.length == 65) && recover(hash, signature) == signer) {\\n            return true;\\n        }\\n        return isValidSignature(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\\n     * @param signer The address to validate the signature against.\\n     * @param hash The hash of the signed data.\\n     * @param v The recovery byte of the signature.\\n     * @param r The first 32 bytes of the signature.\\n     * @param s The second 32 bytes of the signature.\\n     * @return success True if the signature is verified, false otherwise.\\n     */\\n    function recoverOrIsValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool success) {\\n        if (signer == address(0)) return false;\\n        if (recover(hash, v, r, s) == signer) {\\n            return true;\\n        }\\n        return isValidSignature(signer, hash, v, r, s);\\n    }\\n\\n    /**\\n     * @notice Verifies the signature for a hash, either by recovering the signer or using EIP-1271's `isValidSignature` function.\\n     * @dev Attempts to recover the signer's address from the signature; if the address is non-zero, checks if it's valid according to EIP-1271.\\n     * @param signer The address to validate the signature against.\\n     * @param hash The hash of the signed data.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The combined `v` and `s` values of the signature.\\n     * @return success True if the signature is verified, false otherwise.\\n     */\\n    function recoverOrIsValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (bool success) {\\n        if (signer == address(0)) return false;\\n        if (recover(hash, r, vs) == signer) {\\n            return true;\\n        }\\n        return isValidSignature(signer, hash, r, vs);\\n    }\\n\\n    /**\\n     * @notice Verifies the signature for a given hash, attempting to recover the signer's address or validates it using EIP-1271 for 65-byte signatures.\\n     * @dev Attempts to recover the signer's address from the signature. If the address is a contract, checks if the signature is valid according to EIP-1271.\\n     * @param signer The expected signer's address.\\n     * @param hash The keccak256 hash of the signed data.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The last 32 bytes of the signature, with the last byte being the recovery id.\\n     * @return success True if the signature is valid, false otherwise.\\n     */\\n    function recoverOrIsValidSignature65(\\n        address signer,\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (bool success) {\\n        if (signer == address(0)) return false;\\n        if (recover(hash, r, vs) == signer) {\\n            return true;\\n        }\\n        return isValidSignature65(signer, hash, r, vs);\\n    }\\n\\n    /**\\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\\n     * @param hash The hash of the signed data.\\n     * @param signature The signature to validate.\\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\\n     */\\n    function isValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool success) {\\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature));\\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\\n        bytes4 selector = IERC1271.isValidSignature.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            mstore(ptr, selector)\\n            mstore(add(ptr, 0x04), hash)\\n            mstore(add(ptr, 0x24), 0x40)\\n            mstore(add(ptr, 0x44), signature.length)\\n            calldatacopy(add(ptr, 0x64), signature.offset, signature.length)\\n            if staticcall(gas(), signer, ptr, add(0x64, signature.length), 0, 0x20) {\\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\\n     * @param hash The hash of the signed data.\\n     * @param v The recovery byte of the signature.\\n     * @param r The first 32 bytes of the signature.\\n     * @param s The second 32 bytes of the signature.\\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\\n     */\\n    function isValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (bool success) {\\n        bytes4 selector = IERC1271.isValidSignature.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            mstore(ptr, selector)\\n            mstore(add(ptr, 0x04), hash)\\n            mstore(add(ptr, 0x24), 0x40)\\n            mstore(add(ptr, 0x44), 65)\\n            mstore(add(ptr, 0x64), r)\\n            mstore(add(ptr, 0x84), s)\\n            mstore8(add(ptr, 0xa4), v)\\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Validates a signature for a hash using EIP-1271, if `signer` is a contract.\\n     * @dev Makes a static call to `signer` with `isValidSignature` function selector from EIP-1271.\\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\\n     * @param hash The hash of the signed data.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The last 32 bytes of the signature, with the last byte being the recovery id.\\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\\n     */\\n    function isValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (bool success) {\\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs)));\\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\\n        bytes4 selector = IERC1271.isValidSignature.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            mstore(ptr, selector)\\n            mstore(add(ptr, 0x04), hash)\\n            mstore(add(ptr, 0x24), 0x40)\\n            mstore(add(ptr, 0x44), 64)\\n            mstore(add(ptr, 0x64), r)\\n            mstore(add(ptr, 0x84), vs)\\n            if staticcall(gas(), signer, ptr, 0xa4, 0, 0x20) {\\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Verifies if a 65-byte signature is valid for a given hash, according to EIP-1271.\\n     * @param signer The address of the signer to validate against, which could be an EOA or a contract.\\n     * @param hash The hash of the signed data.\\n     * @param r The first 32 bytes of the signature.\\n     * @param vs The combined `v` (recovery id) and `s` component of the signature, packed into the last 32 bytes.\\n     * @return success True if the signature is valid according to EIP-1271, false otherwise.\\n     */\\n    function isValidSignature65(\\n        address signer,\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (bool success) {\\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs & ~uint256(1 << 255), uint8(vs >> 255))));\\n        // return success && data.length == 32 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\\n        bytes4 selector = IERC1271.isValidSignature.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            mstore(ptr, selector)\\n            mstore(add(ptr, 0x04), hash)\\n            mstore(add(ptr, 0x24), 0x40)\\n            mstore(add(ptr, 0x44), 65)\\n            mstore(add(ptr, 0x64), r)\\n            mstore(add(ptr, 0x84), and(vs, _COMPACT_S_MASK))\\n            mstore8(add(ptr, 0xa4), add(27, shr(_COMPACT_V_SHIFT, vs)))\\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Generates a hash compatible with Ethereum's signed message format.\\n     * @dev Prepends the hash with Ethereum's message prefix before hashing it.\\n     * @param hash The hash of the data to sign.\\n     * @return res The Ethereum signed message hash.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 res) {\\n        // 32 is the length in bytes of hash, enforced by the type signature above\\n        // return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"\\n            mstore(28, hash)\\n            res := keccak256(0, 60)\\n        }\\n    }\\n\\n    /**\\n     * @notice Generates an EIP-712 compliant hash.\\n     * @dev Encodes the domain separator and the struct hash according to EIP-712.\\n     * @param domainSeparator The EIP-712 domain separator.\\n     * @param structHash The EIP-712 struct hash.\\n     * @return res The EIP-712 compliant hash.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 res) {\\n        // return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x1901000000000000000000000000000000000000000000000000000000000000) // \\\"\\\\x19\\\\x01\\\"\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            res := keccak256(ptr, 66)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x501b8b300cf98af055d4bb26eb936ec8cb8aac7cde5caae9c2d045a43d15c5e5\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title RevertReasonForwarder\\n * @notice Provides utilities for forwarding and retrieving revert reasons from failed external calls.\\n */\\nlibrary RevertReasonForwarder {\\n    /**\\n     * @dev Forwards the revert reason from the latest external call.\\n     * This method allows propagating the revert reason of a failed external call to the caller.\\n     */\\n    function reRevert() internal pure {\\n        // bubble up revert reason from latest external call\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize())\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the revert reason from the latest external call.\\n     * This method enables capturing the revert reason of a failed external call for inspection or processing.\\n     * @return reason The latest external call revert reason.\\n     */\\n    function reReason() internal pure returns (bytes memory reason) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            reason := mload(0x40)\\n            let length := returndatasize()\\n            mstore(reason, length)\\n            returndatacopy(add(reason, 0x20), 0, length)\\n            mstore(0x40, add(reason, add(0x20, length)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x97d8c950981f4da44ae1b01d9e597c4f99377797ec7ff7b1ef9648e4ecc1baa4\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\nimport \\\"../interfaces/IPermit2.sol\\\";\\nimport \\\"../interfaces/IERC7597Permit.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../libraries/RevertReasonForwarder.sol\\\";\\n\\n/**\\n * @title Implements efficient safe methods for ERC20 interface.\\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\\n * 1. more gas-efficient, providing significant savings in transaction costs.\\n * 2. support for different permit implementations\\n * 3. forceApprove functionality\\n * 4. support for WETH deposit and withdraw\\n */\\nlibrary SafeERC20 {\\n    error SafeTransferFailed();\\n    error SafeTransferFromFailed();\\n    error ForceApproveFailed();\\n    error SafeIncreaseAllowanceFailed();\\n    error SafeDecreaseAllowanceFailed();\\n    error SafePermitBadLength();\\n    error Permit2TransferAmountTooHigh();\\n\\n    // Uniswap Permit2 address\\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n    address private constant _PERMIT2_ZKSYNC = 0x0000000000225e31D15943971F47aD3022F714Fa;\\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\\n\\n    /**\\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\\n     * Consumes less gas then regular `ERC20.balanceOf`.\\n     * @dev Note that the implementation does not perform dirty bits cleaning, so it is the\\n     * responsibility of the caller to make sure that the higher 96 bits of the `account` parameter are clean.\\n     * @param token The IERC20 token contract for which the balance will be fetched.\\n     * @param account The address of the account whose token balance will be fetched.\\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\\n     */\\n    function safeBalanceOf(\\n        IERC20 token,\\n        address account\\n    ) internal view returns(uint256 tokenBalance) {\\n        bytes4 selector = IERC20.balanceOf.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0x00, selector)\\n            mstore(0x04, account)\\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\\n            tokenBalance := mload(0)\\n\\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another.\\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom.\\n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\\n     */\\n    function safeTransferFromUniversal(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool permit2\\n    ) internal {\\n        if (permit2) {\\n            safeTransferFromPermit2(token, from, to, amount);\\n        } else {\\n            safeTransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bytes4 selector = token.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            success := call(gas(), token, 0, data, 0x64, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `from` and `to` parameters are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param from The address from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransferFromPermit2(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\\n        address permit2 = _getPermit2Address();\\n        bytes4 selector = IPermit2.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            mstore(add(data, 0x64), token)\\n            success := call(gas(), permit2, 0, data, 0x84, 0x0, 0x0)\\n            if success {\\n                success := gt(extcodesize(permit2), 0)\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /**\\n     * @notice Attempts to safely transfer tokens to another address.\\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `to` parameter are clean.\\n     * @param token The IERC20 token contract from which the tokens will be transferred.\\n     * @param to The address to which the tokens will be transferred.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (!_makeCall(token, token.transfer.selector, to, amount)) {\\n            revert SafeTransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\\n            if (\\n                !_makeCall(token, token.approve.selector, spender, 0) ||\\n                !_makeCall(token, token.approve.selector, spender, value)\\n            ) {\\n                revert ForceApproveFailed();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely increases the allowance of a spender.\\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to increase the allowance by.\\n     */\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance + value);\\n    }\\n\\n    /**\\n     * @notice Safely decreases the allowance of a spender.\\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\\n     * Then uses `forceApprove` to increase the allowance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `spender` parameter are clean.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to decrease the allowance by.\\n     */\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance - value);\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, bytes calldata permit) internal {\\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters.\\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param owner The owner of the tokens for which the permit is made.\\n     * @param spender The spender allowed to spend the tokens by the permit.\\n     * @param permit The permit data to be used in the function call.\\n     */\\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    /**\\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\\n     * @param token The IERC20 token to execute the permit function on.\\n     * @param permit The permit data to be used in the function call.\\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\\n     */\\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\\n        return tryPermit(token, msg.sender, address(this), permit);\\n    }\\n\\n    /**\\n     * @notice The function attempts to call the permit function on a given ERC20 token.\\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, IERC7597Permit and IPermit2.\\n     * It accommodates both Compact and Full formats of these permit types.\\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter\\n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and\\n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\\n     * before invocation for optimized performance.\\n     * Note that the implementation does not perform dirty bits cleaning, so it is the responsibility of\\n     * the caller to make sure that the higher 96 bits of the `owner` and `spender` parameters are clean.\\n     * @param token The address of the ERC20 token on which to call the permit function.\\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\\n     * @param spender The address which will be approved for transfer of tokens.\\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\\n     * @return success A boolean indicating whether the permit call was successful.\\n     */\\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\\n        address permit2 = _getPermit2Address();\\n        // load function selectors for different permit standards\\n        bytes4 permitSelector = IERC20Permit.permit.selector;\\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\\n        bytes4 permit2Selector = IPermit2.permit.selector;\\n        bytes4 erc7597PermitSelector = IERC7597Permit.permit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n\\n            // Switch case for different permit lengths, indicating different permit standards\\n            switch permit.length\\n            // Compact IERC20Permit\\n            case 100 {\\n                mstore(ptr, permitSelector)     // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\\n\\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\\n                }\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // Compact IDaiLikePermit\\n            case 72 {\\n                mstore(ptr, daiPermitSelector)  // store selector\\n                mstore(add(ptr, 0x04), owner)   // store owner\\n                mstore(add(ptr, 0x24), spender) // store spender\\n\\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\\n\\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\\n                }\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // IERC20Permit\\n            case 224 {\\n                mstore(ptr, permitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            // IDaiLikePermit\\n            case 256 {\\n                mstore(ptr, daiPermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            // Compact IPermit2\\n            case 96 {\\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\\n                mstore(ptr, permit2Selector)  // store selector\\n                mstore(add(ptr, 0x04), owner) // store owner\\n                mstore(add(ptr, 0x24), token) // store token\\n\\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\\n                mstore(add(ptr, 0xa4), spender)                               // store spender\\n                // and(0xffffffffffff, ...) - conversion to uint48\\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), permit2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // IPermit2\\n            case 352 {\\n                mstore(ptr, permit2Selector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), permit2, 0, ptr, 0x164, 0, 0)\\n            }\\n            // Dynamic length\\n            default {\\n                mstore(ptr, erc7597PermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\\n                // IERC7597Permit.permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature)\\n                success := call(gas(), token, 0, ptr, add(permit.length, 4), 0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param selector The function signature that is to be called on the token contract.\\n     * @param to The address to which the token amount will be transferred.\\n     * @param amount The token amount to be transferred.\\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure.\\n     * In case of success but no returned data, validates that the contract code exists.\\n     * In case of returned data, ensures that it's a boolean `true`.\\n     */\\n    function _makeCall(\\n        IERC20 token,\\n        bytes4 selector,\\n        address to,\\n        uint256 amount\\n    ) private returns (bool success) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), to)\\n            mstore(add(data, 0x24), amount)\\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of Ether to deposit into the IWETH contract.\\n     */\\n    function safeDeposit(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.deposit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\\n     * @dev Uses inline assembly to interact with the IWETH contract.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     */\\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.withdraw.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            mstore(4, amount)\\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\\n     * Consumes less gas then regular `IWETH.withdraw`.\\n     * @param weth The IWETH token contract.\\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\\n     * @param to The recipient of the withdrawn Ether.\\n     */\\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\\n        safeWithdraw(weth, amount);\\n        if (to != address(this)) {\\n            assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n                if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getPermit2Address() private view returns (address permit2) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            switch chainid()\\n            case 324 { // zksync mainnet\\n                permit2 := _PERMIT2_ZKSYNC\\n            }\\n            case 300 { // zksync testnet\\n                permit2 := _PERMIT2_ZKSYNC\\n            }\\n            case 260 { // zksync fork network\\n                permit2 := _PERMIT2_ZKSYNC\\n            }\\n            default {\\n                permit2 := _PERMIT2\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc756a120ac3a0271cdfd89db133335deaf31523a06a91ff00eb2be8656e9f85a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x4aaaf1c0737dd16e81f0d2b9833c549747a5ede6873bf1444bc72aa572d03e98\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x27dbc90e5136ffe46c04f7596fc2dbcc3acebd8d504da3d93fdb8496e6de04f6\",\"license\":\"MIT\"},\"contracts/BalanceManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC1271 } from \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IWETH } from \\\"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\\\";\\nimport { RevertReasonForwarder } from \\\"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\\\";\\nimport { SafeERC20 } from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\n\\nimport { IBalanceManager } from \\\"./interfaces/IBalanceManager.sol\\\";\\n\\n/* solhint-disable avoid-low-level-calls */\\n\\nabstract contract BalanceManager is IERC1271, IBalanceManager {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IWETH;\\n\\n    IWETH internal immutable _WETH;\\n\\n    constructor(IWETH weth) {\\n        if (address(weth) == address(0)) revert ZeroAddress();\\n\\n        _WETH = weth;\\n    }\\n\\n    modifier onlyOwner() virtual;\\n\\n    receive() external payable {} // solhint-disable-line no-empty-blocks;\\n\\n    /**\\n     * @notice See {IBalanceManager-arbitraryCalls}.\\n     */\\n    function arbitraryCalls(address[] calldata targets, bytes[] calldata arguments) public payable {\\n        uint256[] calldata values;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            values.offset := calldatasize()\\n            values.length := arguments.length\\n        }\\n        arbitraryCalls(targets, arguments, values);\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-arbitraryCalls}.\\n     */\\n    function arbitraryCalls(address[] calldata targets, bytes[] calldata arguments, uint256[] calldata values) public payable onlyOwner {\\n        unchecked {\\n            uint256 length = targets.length;\\n            if (length != arguments.length) revert LengthMismatch();\\n            if (length != values.length) revert LengthMismatch();\\n            for (uint256 i = 0; i < length; ++i) {\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (bool success,) = targets[i].call{value: values[i]}(arguments[i]);\\n                if (!success) RevertReasonForwarder.reRevert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-arbitraryCallsWithEthCheck}.\\n     */\\n    function arbitraryCallsWithEthCheck(address[] calldata targets, bytes[] calldata arguments, uint256 minReturn) external payable {\\n        uint256[] calldata values;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            values.offset := calldatasize()\\n            values.length := arguments.length\\n        }\\n        arbitraryCallsWithEthCheck(targets, arguments, values, minReturn);\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-arbitraryCallsWithEthCheck}.\\n     */\\n    function arbitraryCallsWithEthCheck(\\n        address[] calldata targets,\\n        bytes[] calldata arguments,\\n        uint256[] calldata values,\\n        uint256 minReturn\\n    ) public payable {\\n        address target = _targetToCheck();\\n        uint256 balanceBefore = target.balance;\\n        arbitraryCalls(targets, arguments, values);\\n        if (target.balance < minReturn + balanceBefore) revert NotEnoughProfit();\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-arbitraryCallsWithTokenCheck}.\\n     */\\n    function arbitraryCallsWithTokenCheck(\\n        address[] calldata targets,\\n        bytes[] calldata arguments,\\n        IERC20 token,\\n        uint256 minReturn\\n    ) external payable {\\n        uint256[] calldata values;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            values.offset := calldatasize()\\n            values.length := arguments.length\\n        }\\n        arbitraryCallsWithTokenCheck(targets, arguments, values, token, minReturn);\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-arbitraryCallsWithTokenCheck}.\\n     */\\n    function arbitraryCallsWithTokenCheck(\\n        address[] calldata targets,\\n        bytes[] calldata arguments,\\n        uint256[] calldata values,\\n        IERC20 token,\\n        uint256 minReturn\\n    ) public payable {\\n        address target = _targetToCheck();\\n        uint256 balanceBefore = token.balanceOf(target);\\n        arbitraryCalls(targets, arguments, values);\\n        if (token.balanceOf(target) < minReturn + balanceBefore) revert NotEnoughProfit();\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-estimateArbitraryCalls}.\\n     */\\n    function estimateArbitraryCalls(address[] calldata targets, bytes[] calldata arguments) external payable {\\n        uint256[] calldata values;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            values.offset := calldatasize()\\n            values.length := arguments.length\\n        }\\n        estimateArbitraryCalls(targets, arguments, values);\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-estimateArbitraryCalls}.\\n     */\\n    function estimateArbitraryCalls(address[] calldata targets, bytes[] calldata arguments, uint256[] calldata values) public payable onlyOwner {\\n        unchecked {\\n            uint256 length = targets.length;\\n            if (length != arguments.length) revert LengthMismatch();\\n            bool[] memory statuses = new bool[](length);\\n            bytes[] memory results = new bytes[](length);\\n            for (uint256 i = 0; i < length; i++) {\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (statuses[i], results[i]) = targets[i].call{value: values[i]}(arguments[i]);\\n            }\\n            revert EstimationResults(statuses, results);\\n        }\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-approve}.\\n     */\\n    function approve(IERC20 token, address to) external onlyOwner {\\n        token.forceApprove(to, type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-transfer}.\\n     */\\n    function transfer(IERC20 token, address to, uint256 amount) external onlyOwner {\\n        token.safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-batchApprove}.\\n     */\\n    function batchApprove(bytes calldata data) external onlyOwner {\\n        unchecked {\\n            uint256 length = data.length;\\n            if (length % 40 != 0) revert InvalidLength();\\n            for (uint256 i = 0; i < length; i += 40) {\\n                IERC20(address(bytes20(data[i:i+20]))).forceApprove(address(bytes20(data[i+20:i+40])), type(uint256).max);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-batchTransfer}.\\n     */\\n    function batchTransfer(bytes calldata data) external onlyOwner {\\n        unchecked {\\n            uint256 length = data.length;\\n            if (length % 72 != 0) revert InvalidLength();\\n            for (uint256 i = 0; i < length; i += 72) {\\n                IERC20 token = IERC20(address(bytes20(data[i:i+20])));\\n                address target = address(bytes20(data[i+20:i+40]));\\n                uint256 amount = uint256(bytes32(data[i+40:i+72]));\\n                token.safeTransfer(target, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-unwrapTo}.\\n     */\\n    function unwrapTo(address payable receiver, uint256 amount) external onlyOwner {\\n        _WETH.safeWithdrawTo(amount, receiver);\\n    }\\n\\n    /**\\n     * @notice See {IBalanceManager-rescueEther}.\\n     */\\n    function rescueEther() external onlyOwner {\\n        (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n        if (!success) revert ETHTransferFailed();\\n    }\\n\\n    function _targetToCheck() internal view virtual returns (address);\\n}\\n\\n/* solhint-enable avoid-low-level-calls */\\n\",\"keccak256\":\"0xc66f345001986c7aa9a97c83271b0dd70652ffc723477b444e44e4698b568da9\",\"license\":\"MIT\"},\"contracts/LeftoverExchanger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IWETH } from \\\"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\\\";\\nimport { ECDSA } from \\\"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\\\";\\n\\nimport { BalanceManager } from \\\"./BalanceManager.sol\\\";\\n\\n/* solhint-disable avoid-low-level-calls */\\n\\ncontract LeftoverExchanger is BalanceManager {\\n    struct Call {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    address private immutable _OWNER;\\n\\n    event CallFailure(uint256 i, bytes result);\\n\\n    error CallFailed(uint256 i, bytes result);\\n\\n    constructor(IWETH weth, address owner) BalanceManager(weth) {\\n        _OWNER = owner;\\n    }\\n\\n    modifier onlyOwner() override {\\n        if(msg.sender != _OWNER) revert OnlyOwner();\\n        _;\\n    }\\n\\n    // TODO: deprecated\\n    function estimateMakeCalls(Call[] calldata calls) external payable onlyOwner {\\n        unchecked {\\n            bool[] memory statuses = new bool[](calls.length);\\n            bytes[] memory results = new bytes[](calls.length);\\n            for (uint256 i = 0; i < calls.length; i++) {\\n                (statuses[i], results[i]) = calls[i].to.call{value : calls[i].value}(calls[i].data);\\n            }\\n            revert EstimationResults(statuses, results);\\n        }\\n    }\\n\\n    // TODO: deprecated\\n    function makeCallsNoThrow(Call[] calldata calls) external payable onlyOwner {\\n        unchecked {\\n            for (uint256 i = 0; i < calls.length; i++) {\\n                (bool ok, bytes memory result) = calls[i].to.call{value : calls[i].value}(calls[i].data);\\n                if (!ok) emit CallFailure(i, result);\\n            }\\n        }\\n    }\\n\\n    // TODO: deprecated\\n    function makeCalls(Call[] calldata calls) public payable onlyOwner {\\n        unchecked {\\n            for (uint256 i = 0; i < calls.length; i++) {\\n                (bool ok, bytes memory result) = calls[i].to.call{value : calls[i].value}(calls[i].data);\\n                if (!ok) revert CallFailed(i, result);\\n            }\\n        }\\n    }\\n\\n    // TODO: deprecated\\n    function makeCallsWithEthCheck(Call[] calldata calls, uint256 minReturn) external payable {\\n        uint256 balanceBefore = msg.sender.balance;\\n        makeCalls(calls);\\n        if (msg.sender.balance - balanceBefore < minReturn) revert NotEnoughProfit();\\n    }\\n\\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view override returns (bytes4 magicValue) {\\n        if (ECDSA.recover(hash, signature) == _OWNER) magicValue = this.isValidSignature.selector;\\n    }\\n\\n    function _targetToCheck() internal view override returns(address) {\\n        return msg.sender;\\n    }\\n}\\n\\n/* solhint-enable avoid-low-level-calls */\\n\",\"keccak256\":\"0xffe0dad35d7600d198e01c7754bda08772dc281e364fc3a26c71b3e1d73cd610\",\"license\":\"MIT\"},\"contracts/interfaces/IBalanceManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Interface to manage contract balance.\\n */\\ninterface IBalanceManager{\\n    error EstimationResults(bool[] statuses, bytes[] results);\\n    error ETHTransferFailed();\\n    error InvalidLength();\\n    error LengthMismatch();\\n    error NotEnoughProfit();\\n    error OnlyOwner();\\n    error ZeroAddress();\\n\\n    /**\\n     * @notice Execute arbitrary calls.\\n     * @param targets Addresses of the contracts to call.\\n     * @param arguments Data to send to each contract.\\n     */\\n    function arbitraryCalls(address[] calldata targets, bytes[] calldata arguments) external payable;\\n\\n    /**\\n     * @notice Execute arbitrary calls.\\n     * @param targets Addresses of the contracts to call.\\n     * @param arguments Data to send to each contract.\\n     * @param values Values to send to each contract.\\n     */\\n    function arbitraryCalls(address[] calldata targets, bytes[] calldata arguments, uint256[] calldata values) external payable;\\n\\n    /**\\n     * @notice Execute arbitrary calls and check the ETH balance after.\\n     * @param targets Addresses of the contracts to call.\\n     * @param arguments Data to send to each contract.\\n     * @param minReturn Minimum amount of ETH balance after all calls.\\n     */\\n    function arbitraryCallsWithEthCheck(address[] calldata targets, bytes[] calldata arguments, uint256 minReturn) external payable;\\n\\n    /**\\n     * @notice Execute arbitrary calls and check the ETH balance after.\\n     * @param targets Addresses of the contracts to call.\\n     * @param arguments Data to send to each contract.\\n     * @param values Values to send to each contract.\\n     * @param minReturn Minimum amount of ETH balance after all calls.\\n     */\\n    function arbitraryCallsWithEthCheck(\\n        address[] calldata targets,\\n        bytes[] calldata arguments,\\n        uint256[] calldata values,\\n        uint256 minReturn\\n    ) external payable;\\n\\n    /**\\n     * @notice Execute arbitrary calls and check the token balance after.\\n     * @param targets Addresses of the contracts to call.\\n     * @param arguments Data to send to each contract.\\n     * @param token Token to check the balance of.\\n     * @param minReturn Minimum amount of token balance after all calls.\\n     */\\n    function arbitraryCallsWithTokenCheck(\\n        address[] calldata targets,\\n        bytes[] calldata arguments,\\n        IERC20 token,\\n        uint256 minReturn\\n    ) external payable;\\n\\n    /**\\n     * @notice Execute arbitrary calls and check the token balance after.\\n     * @param targets Addresses of the contracts to call.\\n     * @param arguments Data to send to each contract.\\n     * @param values Values to send to each contract.\\n     * @param token Token to check the balance of.\\n     * @param minReturn Minimum amount of token balance after all calls.\\n     */\\n    function arbitraryCallsWithTokenCheck(\\n        address[] calldata targets,\\n        bytes[] calldata arguments,\\n        uint256[] calldata values,\\n        IERC20 token,\\n        uint256 minReturn\\n    ) external payable;\\n\\n    /**\\n     * @notice Estimate the results of arbitrary calls.\\n     * @param targets Addresses of the contracts to call.\\n     * @param arguments Data to send to each contract.\\n     * @dev This function reverts results with `EstimationResults` error.\\n     */\\n    function estimateArbitraryCalls(address[] calldata targets, bytes[] calldata arguments) external payable;\\n\\n    /**\\n     * @notice Estimate the results of arbitrary calls.\\n     * @param targets Addresses of the contracts to call.\\n     * @param arguments Data to send to each contract.\\n     * @param values Values to send to each contract.\\n     * @dev This function reverts results with `EstimationResults` error.\\n     */\\n    function estimateArbitraryCalls(address[] calldata targets, bytes[] calldata arguments, uint256[] calldata values) external payable;\\n\\n    /**\\n     * @notice Approves a spender to spend an infinite amount of tokens.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param to The address which will spend the funds.\\n     */\\n    function approve(IERC20 token, address to) external;\\n\\n    /**\\n     * @notice Transfers a certain amount of tokens to a recipient.\\n     * @param token The IERC20 token contract on which the call will be made.\\n     * @param to The address which will receive the funds.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function transfer(IERC20 token, address to, uint256 amount) external;\\n\\n    /**\\n     * @notice Batch approves a spender to spend an infinite amount of multiple tokens.\\n     * @param data The data containing the token addresses and the respective spender addresses.\\n     */\\n    function batchApprove(bytes calldata data) external;\\n\\n    /**\\n     * @notice Batch transfers multiple tokens to the respective recipients.\\n     * @param data The data containing the token addresses, recipients and amounts.\\n     */\\n    function batchTransfer(bytes calldata data) external;\\n\\n    /**\\n     * @notice Unwrap the contract's WETH balance to a recipient.\\n     * @param receiver The address which will receive ETH.\\n     * @param amount The amount of tokens to unwrap.\\n     */\\n    function unwrapTo(address payable receiver, uint256 amount) external;\\n\\n    /**\\n     * @notice Rescue all ETH from the contract.\\n     */\\n    function rescueEther() external;\\n}\\n\\n/* solhint-enable avoid-low-level-calls */\\n\",\"keccak256\":\"0xae6c7a09dec72130dc2d651cc2fb7f8a5ae559de0af5ca6185039b7f7a8251a3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c03461011057601f620021ce38819003918201601f19168301916001600160401b038311848410176101145780849260409485528339810103126101105780516001600160a01b0391828216908183036101105760200151928316830361011057156100fe5760805260a0526040516120a590816200012982396080518161019d015260a05181818161014901528181610273015281816102f401528181610495015281816105ce0152818161070d015281816107a00152818161098901528181610bf701528181610db601528181610e8201528181611003015281816110b001528181611221015281816113a7015281816117e90152611d680152f35b60405163d92e233d60e01b8152600490fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260048036101561001e575b5050361561001c575f80fd5b005b5f3560e01c8063038ec2ab1461149757806310a890af1461133c5780631626ba7e146111915780631f3177ba1461108d57806320969d0714610fbc578063295861b114610e5b578063343590a414610d5057806336669a3214610b915780633a9d666f14610afa5780633d006abd14610a87578063473aaada146109245780634cbdf31c14610898578063785620281461073d5780637e5465ba146106b557806385c01438146105a6578063ba80b51e1461042f578063bdbb216a146102ce578063beabacc8146102195763c12ea3ca03610010573461021557817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557803573ffffffffffffffffffffffffffffffffffffffff9182821680920361021557602435927f00000000000000000000000000000000000000000000000000000000000000001633036101ee5782907f2e1a7d4d000000000000000000000000000000000000000000000000000000005f52525f80602481807f00000000000000000000000000000000000000000000000000000000000000005af1156101e4573081036101cc57005b5f80809381935af1156101db57005b513d5f823e3d90fd5b82513d5f823e3d90fd5b83517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5f80fd5b5090346102155760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557610252611574565b9061025b6116ae565b9073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036102a65761001c6044358385611e92565b8390517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b506102d8366115c5565b73ffffffffffffffffffffffffffffffffffffffff95929391957f0000000000000000000000000000000000000000000000000000000000000000163303610407578084036103df5761032a84611a65565b9561033485611ab4565b945f5b8181106103755785517f9cb0e09d00000000000000000000000000000000000000000000000000000000815280610371898c838d01611c50565b0390fd5b805f8061038d610388600195878b611b1a565b611b57565b610398848936611b1a565b356103a4858a8a611bc9565b9190828d519384928337810185815203925af16103bf6119f0565b6103c9838b611be0565b526103d4828c611be0565b901515905201610337565b8483517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b8483517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5060209160207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557813567ffffffffffffffff81116102155761047b9036908401611543565b73ffffffffffffffffffffffffffffffffffffffff9291927f000000000000000000000000000000000000000000000000000000000000000016330361057e576104c481611a65565b946104ce82611ab4565b935f5b83811061050b5784517f9cb0e09d00000000000000000000000000000000000000000000000000000000815280610371888b838c01611c50565b805f8061051e6103886001958988611d08565b8661052a858a89611d08565b013561054361053a868b8a611d08565b8b810190611b78565b9190828c519384928337810185815203925af161055e6119f0565b610568838a611be0565b52610573828b611be0565b9015159052016104d1565b8382517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b506105b03661162e565b9573ffffffffffffffffffffffffffffffffffffffff9594919392957f000000000000000000000000000000000000000000000000000000000000000016330361068e578582036106675786820361066757505f5b81811061060e57005b5f8061061e61038884868a611b1a565b8a61062a858c8a611b1a565b35610636868c8a611bc9565b8093519384928337810185815203925af161064f6119f0565b501561065d57600101610605565b87513d5f823e3d90fd5b87517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b87517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b50903461021557807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610215576106ed611574565b6106f56116ae565b9173ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036102a65761001c8383611f2a565b5060209160207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557813567ffffffffffffffff8111610215576107899036908401611543565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303610870575f5b8181106107d157005b5f806107e1610388848688611d08565b886107ed858789611d08565b01356108066107fd86888a611d08565b89810190611b78565b9190828a519384928337810185815203925af16108216119f0565b901561083057506001016107c8565b61037186918680519485947f5c0dee5d00000000000000000000000000000000000000000000000000000000865285015260248401526044830190611bf4565b5050517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155767ffffffffffffffff8135818111610215576108e29036908401611543565b602492919235828111610215576108fc9036908601611543565b90926044359081116102155761001c9561091891369101611543565b93909260643595611d48565b50906020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557823567ffffffffffffffff81116102155761096f9036908501611543565b92909373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303610a6057505f5b8381106109bb57005b805f806109ce610388600195898b611d08565b866109da858a8c611d08565b01356109f36109ea868b8d611d08565b88810190611b78565b91908289519384928337810185815203925af1610a0e6119f0565b9015610a1c575b50016109b2565b610a577f446c70d2c3a7ef80e3641bc32468f1f1432635c1425f71d0033aaa78a59cea67918551918291858352878984015287830190611bf4565b0390a15f610a15565b90517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155767ffffffffffffffff813581811161021557610ad19036908401611543565b916024359081116102155761001c93610aec91369101611543565b809291604435943693611d48565b5060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155767ffffffffffffffff813581811161021557610b449036908401611543565b91909260243591821161021557610b5d91369101611543565b6044939193359173ffffffffffffffffffffffffffffffffffffffff83168303610215578161001c95606435953693611779565b5090807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557813567ffffffffffffffff811161021557610bda9036908401611543565b90602433319273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303610d28575f5b818110610c9257505050503331908103908111610c665760243511610c4057005b517f3b5c3088000000000000000000000000000000000000000000000000000000008152fd5b6011837f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b5f80610ca2610388848689611d08565b6020610caf85878a611d08565b0135610cbf61053a86888b611d08565b9190828c519384928337810185815203925af1610cda6119f0565b9015610ce95750600101610c1f565b6103718891888681519586957f5c0dee5d0000000000000000000000000000000000000000000000000000000087528601528401526044830190611bf4565b8585517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b50346102155760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557803567ffffffffffffffff811161021557610d9e9036908301611597565b9173ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036101ee5760289360288406610e355750505f5b828110610df457005b80610e2f6014869301610e12610e0c82858989611994565b906119ac565b610e26610e0c606093878701908a8a611994565b821c911c611f2a565b01610deb565b517f947d5a84000000000000000000000000000000000000000000000000000000008152fd5b50610e653661162e565b96939492909173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303610f9457808603610f6c57610eb886611a65565b97610ec287611ab4565b965f5b8a828210610f01578a6103718b8b519384937f9cb0e09d0000000000000000000000000000000000000000000000000000000085528401611c50565b90600191610f61825f808b8e8c8f868e610f2f8f8f90610f29610388868094610f3699611b1a565b98611b1a565b3593611bc9565b8093519384928337810185815203925af1928d610f5b83610f556119f0565b92611be0565b52611be0565b901515905201610ec5565b8685517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b8685517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b509034610215575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303611067575f80808047335af16110396119f0565b501561104157005b517fb12d13eb000000000000000000000000000000000000000000000000000000008152fd5b517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b50611097366115c5565b909373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016330361116a5781830361114357505f5b8281106110e957005b5f806110f9610388848789611b1a565b611104848636611b1a565b3561111085878b611bc9565b9190828c519384928337810185815203925af161112b6119f0565b5015611139576001016110e0565b85513d5f823e3d90fd5b85517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b85517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b503461021557817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610215576024359167ffffffffffffffff8311610215576111e260209336908401611597565b5f935f928451928386826041146113255750506040146112e257505f9150815b61129a575b505073ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016911614611272575b7fffffffff00000000000000000000000000000000000000000000000000000000905191168152f35b7f1626ba7e000000000000000000000000000000000000000000000000000000009150611249565b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a160608301511015611207578592505f9160809135815282805260015afa505f515f80611207565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81888086940135918260ff1c601b018286015288850137166060820152611202565b80925083919301355f1a8984015281830137611202565b50346102155760209060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557803567ffffffffffffffff81116102155761138d9036908301611597565b92909173ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036114705760489460488506610e355750505f5b8381106113e557005b8061143860148793016113fd610e0c82858a8a611994565b90606091611425611417610e0c6028880180958d8d611994565b841c92878701908b8b611994565b9390359388811061143e575b501c611e92565b016113dc565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90890360031b1b909316925f611431565b84517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5060a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155767ffffffffffffffff8135818111610215576114e19036908401611543565b929091602435818111610215576114fb9036908401611543565b9190926044359182116102155761151491369101611543565b916064359373ffffffffffffffffffffffffffffffffffffffff851685036102155761001c9660843596611779565b9181601f840112156102155782359167ffffffffffffffff8311610215576020808501948460051b01011161021557565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361021557565b9181601f840112156102155782359167ffffffffffffffff8311610215576020838186019501011161021557565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126102155767ffffffffffffffff91600435838111610215578261161091600401611543565b939093926024359182116102155761162a91600401611543565b9091565b9060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126102155767ffffffffffffffff600435818111610215578361167991600401611543565b93909392602435838111610215578261169491600401611543565b939093926044359182116102155761162a91600401611543565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361021557565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761171257604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b9190820180921161174c57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b969490969593919573ffffffffffffffffffffffffffffffffffffffff809516926040978851957f70a08231000000000000000000000000000000000000000000000000000000009485885260049b338d8a01526020998a8a6024818c5afa998a1561198a575f9a61195b575b507f00000000000000000000000000000000000000000000000000000000000000001633036119335782810361190b5781810361190b5790899695949392915f5b8d82821061189d57955050505050506024915051809481938252338b8301525afa928315611139575f9361186b575b5050611862919261173f565b11610c40575050565b90809350813d8311611896575b61188281836116d1565b81010312610215576118629151915f611856565b503d611878565b879899505f91929394959697906118b961038885878695611b1a565b906118c585888c611b1a565b356118d1868a8c611bc9565b8093519384928337810185815203925af16118ea6119f0565b501561190157600101908a97969594939291611827565b8c513d5f823e3d90fd5b8c8c517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b8c8c517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b9099508a81813d8311611983575b61197381836116d1565b810103126102155751985f6117e6565b503d611969565b8d513d5f823e3d90fd5b90939293848311610215578411610215578101920390565b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000090358181169392601481106119e157505050565b60140360031b82901b16169150565b3d15611a48573d9067ffffffffffffffff82116117125760405191611a3d60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601846116d1565b82523d5f602084013e565b606090565b67ffffffffffffffff81116117125760051b60200190565b90611a6f82611a4d565b611a7c60405191826116d1565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611aaa8294611a4d565b0190602036910137565b90611abe82611a4d565b611acb60405191826116d1565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611af98294611a4d565b01905f5b828110611b0957505050565b806060602080938501015201611afd565b9190811015611b2a5760051b0190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b3573ffffffffffffffffffffffffffffffffffffffff811681036102155790565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe181360301821215610215570180359067ffffffffffffffff82116102155760200191813603831361021557565b90821015611b2a5761162a9160051b810190611b78565b8051821015611b2a5760209160051b010190565b91908251928382525f5b848110611c3c5750507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f845f6020809697860101520116010190565b602081830181015184830182015201611bfe565b90604082019160408152815180935260608101926020809301905f5b818110611cf257505050818184039101528251908183528083019281808460051b8301019501935f915b848310611ca65750505050505090565b9091929394958480611ce2837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe086600196030187528a51611bf4565b9801930193019194939290611c96565b8251151586529484019491840191600101611c6c565b9190811015611b2a5760051b810135907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa181360301821215610215570190565b92909493919333319573ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303611e6857828103611e3e57818103611e3e575f5b818110611de95750505050505050611db89033319261173f565b11611dbf57565b60046040517f3b5c3088000000000000000000000000000000000000000000000000000000008152fd5b611df7610388828489611b1a565b5f80611e0484878a611b1a565b3592611e1185898d611bc9565b90946040958287519384928337810185815203925af1611e2f6119f0565b50156101db5750600101611d9e565b60046040517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b60046040517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b9160446020925f92604051917fa9059cbb0000000000000000000000000000000000000000000000000000000083526004830152602482015282855af19081611f08575b5015611ede57565b60046040517ffb7f5079000000000000000000000000000000000000000000000000000000008152fd5b90503d15611f22575060015f5114601f3d11165b5f611ed6565b3b1515611f1c565b90611f358183611feb565b15611f3e575050565b60205f60446040517f095ea7b300000000000000000000000000000000000000000000000000000000815284600482015282602482015282865af180611fcc575b15918215611fba575b5050611f9057565b60046040517f19be9a90000000000000000000000000000000000000000000000000000000008152fd5b611fc49250611feb565b155f80611f88565b503d15611fe25760015f5114601f3d1116611f7f565b813b1515611f7f565b91905f6044602092604051907f095ea7b300000000000000000000000000000000000000000000000000000000825260048201527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602482015282865af191826120525750565b9091503d15612069575060015f5114601f3d111690565b3b15159056fea26469706673582212204eca54cfb77c75767d4698f130d811ae9b6de4fa717bbf7d166d55b6614bb03d64736f6c63430008170033",
  "deployedBytecode": "0x60406080815260048036101561001e575b5050361561001c575f80fd5b005b5f3560e01c8063038ec2ab1461149757806310a890af1461133c5780631626ba7e146111915780631f3177ba1461108d57806320969d0714610fbc578063295861b114610e5b578063343590a414610d5057806336669a3214610b915780633a9d666f14610afa5780633d006abd14610a87578063473aaada146109245780634cbdf31c14610898578063785620281461073d5780637e5465ba146106b557806385c01438146105a6578063ba80b51e1461042f578063bdbb216a146102ce578063beabacc8146102195763c12ea3ca03610010573461021557817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557803573ffffffffffffffffffffffffffffffffffffffff9182821680920361021557602435927f00000000000000000000000000000000000000000000000000000000000000001633036101ee5782907f2e1a7d4d000000000000000000000000000000000000000000000000000000005f52525f80602481807f00000000000000000000000000000000000000000000000000000000000000005af1156101e4573081036101cc57005b5f80809381935af1156101db57005b513d5f823e3d90fd5b82513d5f823e3d90fd5b83517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5f80fd5b5090346102155760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557610252611574565b9061025b6116ae565b9073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036102a65761001c6044358385611e92565b8390517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b506102d8366115c5565b73ffffffffffffffffffffffffffffffffffffffff95929391957f0000000000000000000000000000000000000000000000000000000000000000163303610407578084036103df5761032a84611a65565b9561033485611ab4565b945f5b8181106103755785517f9cb0e09d00000000000000000000000000000000000000000000000000000000815280610371898c838d01611c50565b0390fd5b805f8061038d610388600195878b611b1a565b611b57565b610398848936611b1a565b356103a4858a8a611bc9565b9190828d519384928337810185815203925af16103bf6119f0565b6103c9838b611be0565b526103d4828c611be0565b901515905201610337565b8483517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b8483517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5060209160207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557813567ffffffffffffffff81116102155761047b9036908401611543565b73ffffffffffffffffffffffffffffffffffffffff9291927f000000000000000000000000000000000000000000000000000000000000000016330361057e576104c481611a65565b946104ce82611ab4565b935f5b83811061050b5784517f9cb0e09d00000000000000000000000000000000000000000000000000000000815280610371888b838c01611c50565b805f8061051e6103886001958988611d08565b8661052a858a89611d08565b013561054361053a868b8a611d08565b8b810190611b78565b9190828c519384928337810185815203925af161055e6119f0565b610568838a611be0565b52610573828b611be0565b9015159052016104d1565b8382517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b506105b03661162e565b9573ffffffffffffffffffffffffffffffffffffffff9594919392957f000000000000000000000000000000000000000000000000000000000000000016330361068e578582036106675786820361066757505f5b81811061060e57005b5f8061061e61038884868a611b1a565b8a61062a858c8a611b1a565b35610636868c8a611bc9565b8093519384928337810185815203925af161064f6119f0565b501561065d57600101610605565b87513d5f823e3d90fd5b87517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b87517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b50903461021557807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610215576106ed611574565b6106f56116ae565b9173ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036102a65761001c8383611f2a565b5060209160207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557813567ffffffffffffffff8111610215576107899036908401611543565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303610870575f5b8181106107d157005b5f806107e1610388848688611d08565b886107ed858789611d08565b01356108066107fd86888a611d08565b89810190611b78565b9190828a519384928337810185815203925af16108216119f0565b901561083057506001016107c8565b61037186918680519485947f5c0dee5d00000000000000000000000000000000000000000000000000000000865285015260248401526044830190611bf4565b5050517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155767ffffffffffffffff8135818111610215576108e29036908401611543565b602492919235828111610215576108fc9036908601611543565b90926044359081116102155761001c9561091891369101611543565b93909260643595611d48565b50906020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557823567ffffffffffffffff81116102155761096f9036908501611543565b92909373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303610a6057505f5b8381106109bb57005b805f806109ce610388600195898b611d08565b866109da858a8c611d08565b01356109f36109ea868b8d611d08565b88810190611b78565b91908289519384928337810185815203925af1610a0e6119f0565b9015610a1c575b50016109b2565b610a577f446c70d2c3a7ef80e3641bc32468f1f1432635c1425f71d0033aaa78a59cea67918551918291858352878984015287830190611bf4565b0390a15f610a15565b90517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155767ffffffffffffffff813581811161021557610ad19036908401611543565b916024359081116102155761001c93610aec91369101611543565b809291604435943693611d48565b5060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155767ffffffffffffffff813581811161021557610b449036908401611543565b91909260243591821161021557610b5d91369101611543565b6044939193359173ffffffffffffffffffffffffffffffffffffffff83168303610215578161001c95606435953693611779565b5090807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557813567ffffffffffffffff811161021557610bda9036908401611543565b90602433319273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303610d28575f5b818110610c9257505050503331908103908111610c665760243511610c4057005b517f3b5c3088000000000000000000000000000000000000000000000000000000008152fd5b6011837f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b5f80610ca2610388848689611d08565b6020610caf85878a611d08565b0135610cbf61053a86888b611d08565b9190828c519384928337810185815203925af1610cda6119f0565b9015610ce95750600101610c1f565b6103718891888681519586957f5c0dee5d0000000000000000000000000000000000000000000000000000000087528601528401526044830190611bf4565b8585517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b50346102155760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557803567ffffffffffffffff811161021557610d9e9036908301611597565b9173ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036101ee5760289360288406610e355750505f5b828110610df457005b80610e2f6014869301610e12610e0c82858989611994565b906119ac565b610e26610e0c606093878701908a8a611994565b821c911c611f2a565b01610deb565b517f947d5a84000000000000000000000000000000000000000000000000000000008152fd5b50610e653661162e565b96939492909173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303610f9457808603610f6c57610eb886611a65565b97610ec287611ab4565b965f5b8a828210610f01578a6103718b8b519384937f9cb0e09d0000000000000000000000000000000000000000000000000000000085528401611c50565b90600191610f61825f808b8e8c8f868e610f2f8f8f90610f29610388868094610f3699611b1a565b98611b1a565b3593611bc9565b8093519384928337810185815203925af1928d610f5b83610f556119f0565b92611be0565b52611be0565b901515905201610ec5565b8685517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b8685517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b509034610215575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303611067575f80808047335af16110396119f0565b501561104157005b517fb12d13eb000000000000000000000000000000000000000000000000000000008152fd5b517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b50611097366115c5565b909373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016330361116a5781830361114357505f5b8281106110e957005b5f806110f9610388848789611b1a565b611104848636611b1a565b3561111085878b611bc9565b9190828c519384928337810185815203925af161112b6119f0565b5015611139576001016110e0565b85513d5f823e3d90fd5b85517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b85517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b503461021557817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610215576024359167ffffffffffffffff8311610215576111e260209336908401611597565b5f935f928451928386826041146113255750506040146112e257505f9150815b61129a575b505073ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016911614611272575b7fffffffff00000000000000000000000000000000000000000000000000000000905191168152f35b7f1626ba7e000000000000000000000000000000000000000000000000000000009150611249565b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a160608301511015611207578592505f9160809135815282805260015afa505f515f80611207565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81888086940135918260ff1c601b018286015288850137166060820152611202565b80925083919301355f1a8984015281830137611202565b50346102155760209060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021557803567ffffffffffffffff81116102155761138d9036908301611597565b92909173ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036114705760489460488506610e355750505f5b8381106113e557005b8061143860148793016113fd610e0c82858a8a611994565b90606091611425611417610e0c6028880180958d8d611994565b841c92878701908b8b611994565b9390359388811061143e575b501c611e92565b016113dc565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90890360031b1b909316925f611431565b84517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b5060a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102155767ffffffffffffffff8135818111610215576114e19036908401611543565b929091602435818111610215576114fb9036908401611543565b9190926044359182116102155761151491369101611543565b916064359373ffffffffffffffffffffffffffffffffffffffff851685036102155761001c9660843596611779565b9181601f840112156102155782359167ffffffffffffffff8311610215576020808501948460051b01011161021557565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361021557565b9181601f840112156102155782359167ffffffffffffffff8311610215576020838186019501011161021557565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126102155767ffffffffffffffff91600435838111610215578261161091600401611543565b939093926024359182116102155761162a91600401611543565b9091565b9060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126102155767ffffffffffffffff600435818111610215578361167991600401611543565b93909392602435838111610215578261169491600401611543565b939093926044359182116102155761162a91600401611543565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361021557565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761171257604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b9190820180921161174c57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b969490969593919573ffffffffffffffffffffffffffffffffffffffff809516926040978851957f70a08231000000000000000000000000000000000000000000000000000000009485885260049b338d8a01526020998a8a6024818c5afa998a1561198a575f9a61195b575b507f00000000000000000000000000000000000000000000000000000000000000001633036119335782810361190b5781810361190b5790899695949392915f5b8d82821061189d57955050505050506024915051809481938252338b8301525afa928315611139575f9361186b575b5050611862919261173f565b11610c40575050565b90809350813d8311611896575b61188281836116d1565b81010312610215576118629151915f611856565b503d611878565b879899505f91929394959697906118b961038885878695611b1a565b906118c585888c611b1a565b356118d1868a8c611bc9565b8093519384928337810185815203925af16118ea6119f0565b501561190157600101908a97969594939291611827565b8c513d5f823e3d90fd5b8c8c517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b8c8c517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b9099508a81813d8311611983575b61197381836116d1565b810103126102155751985f6117e6565b503d611969565b8d513d5f823e3d90fd5b90939293848311610215578411610215578101920390565b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000090358181169392601481106119e157505050565b60140360031b82901b16169150565b3d15611a48573d9067ffffffffffffffff82116117125760405191611a3d60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601846116d1565b82523d5f602084013e565b606090565b67ffffffffffffffff81116117125760051b60200190565b90611a6f82611a4d565b611a7c60405191826116d1565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611aaa8294611a4d565b0190602036910137565b90611abe82611a4d565b611acb60405191826116d1565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611af98294611a4d565b01905f5b828110611b0957505050565b806060602080938501015201611afd565b9190811015611b2a5760051b0190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b3573ffffffffffffffffffffffffffffffffffffffff811681036102155790565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe181360301821215610215570180359067ffffffffffffffff82116102155760200191813603831361021557565b90821015611b2a5761162a9160051b810190611b78565b8051821015611b2a5760209160051b010190565b91908251928382525f5b848110611c3c5750507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f845f6020809697860101520116010190565b602081830181015184830182015201611bfe565b90604082019160408152815180935260608101926020809301905f5b818110611cf257505050818184039101528251908183528083019281808460051b8301019501935f915b848310611ca65750505050505090565b9091929394958480611ce2837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe086600196030187528a51611bf4565b9801930193019194939290611c96565b8251151586529484019491840191600101611c6c565b9190811015611b2a5760051b810135907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa181360301821215610215570190565b92909493919333319573ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163303611e6857828103611e3e57818103611e3e575f5b818110611de95750505050505050611db89033319261173f565b11611dbf57565b60046040517f3b5c3088000000000000000000000000000000000000000000000000000000008152fd5b611df7610388828489611b1a565b5f80611e0484878a611b1a565b3592611e1185898d611bc9565b90946040958287519384928337810185815203925af1611e2f6119f0565b50156101db5750600101611d9e565b60046040517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b60046040517f5fc483c5000000000000000000000000000000000000000000000000000000008152fd5b9160446020925f92604051917fa9059cbb0000000000000000000000000000000000000000000000000000000083526004830152602482015282855af19081611f08575b5015611ede57565b60046040517ffb7f5079000000000000000000000000000000000000000000000000000000008152fd5b90503d15611f22575060015f5114601f3d11165b5f611ed6565b3b1515611f1c565b90611f358183611feb565b15611f3e575050565b60205f60446040517f095ea7b300000000000000000000000000000000000000000000000000000000815284600482015282602482015282865af180611fcc575b15918215611fba575b5050611f9057565b60046040517f19be9a90000000000000000000000000000000000000000000000000000000008152fd5b611fc49250611feb565b155f80611f88565b503d15611fe25760015f5114601f3d1116611f7f565b813b1515611f7f565b91905f6044602092604051907f095ea7b300000000000000000000000000000000000000000000000000000000825260048201527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602482015282865af191826120525750565b9091503d15612069575060015f5114601f3d111690565b3b15159056fea26469706673582212204eca54cfb77c75767d4698f130d811ae9b6de4fa717bbf7d166d55b6614bb03d64736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "isValidSignature(bytes32,bytes)": {
        "details": "Should return whether the signature provided is valid for the provided data",
        "params": {
          "hash": "Hash of the data to be signed",
          "signature": "Signature byte array associated with _data"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "approve(address,address)": {
        "notice": "See {IBalanceManager-approve}."
      },
      "arbitraryCalls(address[],bytes[])": {
        "notice": "See {IBalanceManager-arbitraryCalls}."
      },
      "arbitraryCalls(address[],bytes[],uint256[])": {
        "notice": "See {IBalanceManager-arbitraryCalls}."
      },
      "arbitraryCallsWithEthCheck(address[],bytes[],uint256)": {
        "notice": "See {IBalanceManager-arbitraryCallsWithEthCheck}."
      },
      "arbitraryCallsWithEthCheck(address[],bytes[],uint256[],uint256)": {
        "notice": "See {IBalanceManager-arbitraryCallsWithEthCheck}."
      },
      "arbitraryCallsWithTokenCheck(address[],bytes[],address,uint256)": {
        "notice": "See {IBalanceManager-arbitraryCallsWithTokenCheck}."
      },
      "arbitraryCallsWithTokenCheck(address[],bytes[],uint256[],address,uint256)": {
        "notice": "See {IBalanceManager-arbitraryCallsWithTokenCheck}."
      },
      "batchApprove(bytes)": {
        "notice": "See {IBalanceManager-batchApprove}."
      },
      "batchTransfer(bytes)": {
        "notice": "See {IBalanceManager-batchTransfer}."
      },
      "estimateArbitraryCalls(address[],bytes[])": {
        "notice": "See {IBalanceManager-estimateArbitraryCalls}."
      },
      "estimateArbitraryCalls(address[],bytes[],uint256[])": {
        "notice": "See {IBalanceManager-estimateArbitraryCalls}."
      },
      "rescueEther()": {
        "notice": "See {IBalanceManager-rescueEther}."
      },
      "transfer(address,address,uint256)": {
        "notice": "See {IBalanceManager-transfer}."
      },
      "unwrapTo(address,uint256)": {
        "notice": "See {IBalanceManager-unwrapTo}."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}