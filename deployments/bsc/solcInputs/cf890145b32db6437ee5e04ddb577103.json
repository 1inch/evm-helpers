{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/AlgebraHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/IAlgebra.sol\";\n\ncontract AlgebraHelper {\n    int24 private constant _MIN_TICK = -887272;\n    int24 private constant _MAX_TICK = -_MIN_TICK;\n\n    uint16 internal constant _BASE_FEE = 100;\n    int24 internal constant _TICK_SPACING = 60;\n\n    struct Tick {\n        uint128 liquidityGross;\n        int128 liquidityNet;\n        uint256 feeGrowthOutside0X128;\n        uint256 feeGrowthOutside1X128;\n        int56 tickCumulativeOutside;\n        uint160 secondsPerLiquidityOutsideX128;\n        uint32 secondsOutside;\n        int24 index; // tick index\n    }\n\n    function getTicks(IAlgebra pool, int24 tickRange) external view returns (bytes[] memory ticks) {\n        (,int24 tick,,,,,) = pool.globalState();\n\n        tickRange *= _TICK_SPACING;\n        int24 fromTick = tick - tickRange;\n        int24 toTick = tick + tickRange;\n        if (fromTick < _MIN_TICK) {\n            fromTick = _MIN_TICK;\n        }\n        if (toTick > _MAX_TICK) {\n            toTick = _MAX_TICK;\n        }\n\n        int24[] memory initTicks = new int24[](uint256(int256((toTick - fromTick + 1) / _TICK_SPACING)));\n\n        uint256 counter = 0;\n        int16 pos = int16((fromTick / _TICK_SPACING) >> 8);\n        int16 endPos = int16((toTick / _TICK_SPACING) >> 8);\n        for (; pos <= endPos; pos++) {\n            uint256 bm = pool.tickTable(pos);\n\n            while (bm != 0) {\n                uint8 bit = _leastSignificantBit(bm);\n                bm ^= 1 << bit;\n                int24 extractedTick = ((int24(pos) << 8) | int24(uint24(bit))) * _TICK_SPACING;\n                if (extractedTick >= fromTick && extractedTick <= toTick) {\n                    initTicks[counter++] = extractedTick;\n                }\n            }\n        }\n\n        ticks = new bytes[](counter);\n        for (uint256 i = 0; i < counter; i++) {\n            (\n                uint128 liquidityTotal,\n                int128 liquidityDelta,\n                uint256 outerFeeGrowth0Token,\n                uint256 outerFeeGrowth1Token\n                , // int56 outerTickCumulative,\n                , // uint160 outerSecondsPerLiquidity\n                , // uint32 outerSecondsSpent\n                , // bool initialized\n            ) = pool.ticks(initTicks[i]);\n\n            ticks[i] = abi.encodePacked(\n                liquidityTotal,\n                liquidityDelta,\n                outerFeeGrowth0Token,\n                outerFeeGrowth1Token,\n                // outerTickCumulative,\n                // outerSecondsPerLiquidity,\n                // outerSecondsSpent,\n                initTicks[i]\n            );\n        }\n    }\n\n    function _leastSignificantBit(uint256 x) private pure returns (uint8 r) {\n        require(x > 0, \"x is 0\");\n        x = x & (~x + 1);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n}\n"
    },
    "contracts/Ether.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n\ncontract Ether {\n    function balanceOf(address wallet) external view returns (uint256) {\n        return wallet.balance;\n    }\n}\n"
    },
    "contracts/EvmHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./Ether.sol\";\nimport \"./MultiCall.sol\";\nimport \"./UniV3Helper.sol\";\n\n//solhint-disable-next-line no-empty-blocks\ncontract EvmHelpers is Ether, MultiCall, UniV3Helper {}\n"
    },
    "contracts/interfaces/IAlgebra.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n\ninterface IAlgebra {\n    /**\n    * @notice The globalState structure in the pool stores many values but requires only one slot\n    * and is exposed as a single method to save gas when accessed externally.\n    * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value;\n    * Returns tick The current tick of the pool, i.e. according to the last tick transition that was run;\n    * Returns This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\n    * boundary;\n    * Returns fee The last pool fee value in hundredths of a bip, i.e. 1e-6;\n    * Returns timepointIndex The index of the last written timepoint;\n    * Returns communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0;\n    * Returns communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1;\n    * Returns unlocked Whether the pool is currently locked to reentrancy;\n    */\n    function globalState()\n        external\n        view\n        returns (\n            uint160 price,\n            int24 tick,\n            uint16 fee,\n            uint16 timepointIndex,\n            uint8 communityFeeToken0,\n            uint8 communityFeeToken1,\n            bool unlocked\n        );\n\n    /**\n    * @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    * @dev This value can overflow the uint256\n    */\n    function totalFeeGrowth0Token() external view returns (uint256);\n\n    /**\n    * @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    * @dev This value can overflow the uint256\n    */\n    function totalFeeGrowth1Token() external view returns (uint256);\n\n    /**\n    * @notice The currently in range liquidity available to the pool\n    * @dev This value has no relationship to the total liquidity across all ticks.\n    * Returned value cannot exceed type(uint128).max\n    */\n    function liquidity() external view returns (uint128);\n\n    /**\n    * @notice Look up information about a specific tick in the pool\n    * @dev This is a public structure, so the `return` natspec tags are omitted.\n    * @param tick The tick to look up\n    * @return liquidityTotal the total amount of position liquidity that uses the pool either as tick lower or\n    * tick upper\n    * @return liquidityDelta how much liquidity changes when the pool price crosses the tick;\n    * Returns outerFeeGrowth0Token the fee growth on the other side of the tick from the current tick in token0;\n    * Returns outerFeeGrowth1Token the fee growth on the other side of the tick from the current tick in token1;\n    * Returns outerTickCumulative the cumulative tick value on the other side of the tick from the current tick;\n    * Returns outerSecondsPerLiquidity the seconds spent per liquidity on the other side of the tick from the current tick;\n    * Returns outerSecondsSpent the seconds spent on the other side of the tick from the current tick;\n    * Returns initialized Set to true if the tick is initialized, i.e. liquidityTotal is greater than 0\n    * otherwise equal to false. Outside values can only be used if the tick is initialized.\n    * In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    * a specific position.\n    */\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityTotal,\n            int128 liquidityDelta,\n            uint256 outerFeeGrowth0Token,\n            uint256 outerFeeGrowth1Token,\n            int56 outerTickCumulative,\n            uint160 outerSecondsPerLiquidity,\n            uint32 outerSecondsSpent,\n            bool initialized\n        );\n\n    /** @notice Returns 256 packed tick initialized boolean values. See TickTable for more information */\n    function tickTable(int16 wordPosition) external view returns (uint256);\n\n    /**\n    * @notice Returns the information about a position by the position's key\n    * @dev This is a public mapping of structures, so the `return` natspec tags are omitted.\n    * @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\n    * @return liquidityAmount The amount of liquidity in the position;\n    * Returns lastLiquidityAddTimestamp Timestamp of last adding of liquidity;\n    * Returns innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke;\n    * Returns innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke;\n    * Returns fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke;\n    * Returns fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\n    */\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 liquidityAmount,\n            uint32 lastLiquidityAddTimestamp,\n            uint256 innerFeeGrowth0Token,\n            uint256 innerFeeGrowth1Token,\n            uint128 fees0,\n            uint128 fees1\n        );\n}\n"
    },
    "contracts/interfaces/IJoePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IJoePair {\n\tfunction findFirstNonEmptyBinId(uint24 _id, bool _swapForY) external view returns (uint24);\n    function getBin(uint24 _id) external view returns (uint256 reserveX, uint256 reserveY);\n}\n"
    },
    "contracts/interfaces/ILBPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface ILBPair {\n\tfunction getNextNonEmptyBin(bool _swapForY, uint24 _id) external view returns (uint24 nextId);\n    function getBin(uint24 _id) external view returns (uint128 binReserveX, uint128 binReserveY);\n}\n"
    },
    "contracts/interfaces/IMasterWombatV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IAsset {\n    function pool() external view returns(address);\n    function underlyingToken() external view returns(address);\n}\n\ninterface IPool {\n    function getTokens() external view returns (address[] memory);\n}\n\ninterface IMasterWombatV3 {\n    function poolInfoV3(uint256 i) external view\n    returns (\n        address lpToken,\n        address rewarder,\n        uint40 periodFinish,\n        uint128 sumOfFactors,\n        uint128 rewardRate,\n        uint104 accWomPerShare,\n        uint104 accWomPerFactorShare,\n        uint40 lastRewardTimestamp\n    );\n\n    function poolLength() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IUniswapV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n\ninterface IUniswapV3 {\n    function tickSpacing() external view returns (int24);\n\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    function liquidity() external view returns (uint128);\n\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "contracts/LeftoverExchanger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\ncontract LeftoverExchanger is Ownable {\n    event Action (bool success, address to, bytes result);\n\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    constructor(address owner_) {\n        transferOwnership(owner_);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    // payable for paths with 0x\n    function makeCallsNoThrow(Call[] calldata calls) external payable onlyOwner {\n        uint256 startGas = gasleft();\n        for (uint i = 0; i < calls.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool ok, bytes memory result) = calls[i].to.call{value : calls[i].value}(calls[i].data);\n            emit Action(ok, calls[i].to, result);\n        }\n        uint256 gasRefund = (startGas - gasleft() + 21000 + (msg.data.length * 7) + 2000) * tx.gasprice;\n        if (address(this).balance >= gasRefund) {\n            (bool ok,) = payable(owner()).call{value: gasRefund}(\"\");\n            require(ok, \"refund failed\");\n        }\n    }\n\n    // payable for paths with 0x\n    function makeCalls(Call[] calldata calls) external payable onlyOwner {\n        for (uint i = 0; i < calls.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool ok,) = calls[i].to.call{value : calls[i].value}(calls[i].data);\n            require(ok, \"swap failed\");\n        }\n    }\n}\n"
    },
    "contracts/MultiCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n\ncontract MultiCall {\n    struct Call {\n        address to;\n        bytes data;\n    }\n\n   function multicall(Call[] memory calls) public returns (bytes[] memory results) {\n        results = new bytes[](calls.length);\n        for (uint i = 0; i < calls.length; i++) {\n            (, results[i]) = calls[i].to.call(calls[i].data);  // solhint-disable-line avoid-low-level-calls\n        }\n    }\n\n\n    // be careful with calls.length == 0\n    function multicallWithGasLimitation(Call[] memory calls, uint256 gasBuffer) public returns (bytes[] memory results, uint256 lastSuccessIndex) {\n        results = new bytes[](calls.length);\n        for (uint i = 0; i < calls.length; i++) {\n            (, results[i]) = calls[i].to.call(calls[i].data);  // solhint-disable-line avoid-low-level-calls\n            if (gasleft() < gasBuffer) {\n                return (results, i);\n            }\n        }\n        return (results, calls.length - 1);\n    }\n\n   function multicallWithGas(Call[] memory calls) public returns (bytes[] memory results, uint256[] memory gasUsed) {\n        results = new bytes[](calls.length);\n        gasUsed = new uint256[](calls.length);\n        for (uint i = 0; i < calls.length; i++) {\n            uint256 initialGas = gasleft();\n            (, results[i]) = calls[i].to.call(calls[i].data);  // solhint-disable-line avoid-low-level-calls\n            gasUsed[i] = initialGas - gasleft();\n        }\n    }\n\n    function gaslimit() external view returns (uint256) {\n        return block.gaslimit;\n    }\n\n    function gasLeft() external view returns (uint256) {\n        return gasleft();\n    }\n}\n"
    },
    "contracts/TraderJoeHelper_v2_1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/ILBPair.sol\";\n\ncontract TraderJoeHelper_v2_1 {\n    struct BinData {\n        uint256 id;\n        uint256 reserveX;\n        uint256 reserveY;\n    }\n\n    function getBins(ILBPair pair, uint24 offset, uint24 size)\n        external\n        view\n        returns (BinData[] memory data, uint24 i)\n    {\n        uint256 counter = 0;\n        data = new BinData[](size);\n        uint24 lastBin = pair.getNextNonEmptyBin(true, type(uint24).max);\n        for (\n            i = offset;\n            i < lastBin && counter < size;\n            i = pair.getNextNonEmptyBin(false, i)\n        ) {\n            (uint256 x, uint256 y) = pair.getBin(i);\n            if (x > 0 || y > 0) {\n                (data[counter].reserveX, data[counter].reserveY) = (x, y);\n                data[counter].id = i;\n                unchecked{ ++counter; }\n            }\n        }\n        if (i == lastBin && counter < size) {\n            (data[counter].reserveX, data[counter].reserveY) = pair.getBin(i);\n            data[counter].id = i;\n            unchecked{ ++counter; }\n            i = 0;\n        }\n        // cut array size down\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(data, counter)\n        }\n    }\n}\n"
    },
    "contracts/TraderJoeHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/IJoePair.sol\";\n\ncontract TraderJoeHelper {\n    struct BinData {\n        uint256 id;\n        uint256 reserveX;\n        uint256 reserveY;\n    }\n\n    function getBins(IJoePair pair, uint24 offset, uint24 size)\n        external\n        view\n        returns (BinData[] memory data, uint24 i)\n    {\n        uint256 counter = 0;\n        data = new BinData[](size);\n        uint24 lastBin = pair.findFirstNonEmptyBinId(type(uint24).max, true);\n        for (\n            i = offset;\n            i < lastBin && counter < size;\n            i = pair.findFirstNonEmptyBinId(i, false)\n        ) {\n            (uint256 x, uint256 y) = pair.getBin(i);\n            if (x > 0 || y > 0) {\n                (data[counter].reserveX, data[counter].reserveY) = (x, y);\n                data[counter].id = i;\n                unchecked{ ++counter; }\n            }\n        }\n        if (i == lastBin && counter < size) {\n            (data[counter].reserveX, data[counter].reserveY) = pair.getBin(i);\n            data[counter].id = i;\n            unchecked{ ++counter; }\n            i = 0;\n        }\n        // cut array size down\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(data, counter)\n        }\n    }\n}\n"
    },
    "contracts/UniV3Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/IUniswapV3.sol\";\n\ncontract UniV3Helper {\n    int24 private constant _MIN_TICK = -887272;\n    int24 private constant _MAX_TICK = -_MIN_TICK;\n\n    struct Tick {\n        uint128 liquidityGross;\n        int128 liquidityNet;\n        uint256 feeGrowthOutside0X128;\n        uint256 feeGrowthOutside1X128;\n        int56 tickCumulativeOutside;\n        uint160 secondsPerLiquidityOutsideX128;\n        uint32 secondsOutside;\n        int24 index; // tick index\n    }\n\n    function getTicks(IUniswapV3 pool, int24 tickRange) external view returns (bytes[] memory ticks) {\n        int24 tickSpacing = pool.tickSpacing();\n        (,int24 tick,,,,,) = pool.slot0();\n\n        tickRange *= tickSpacing;\n        int24 fromTick = tick - tickRange;\n        int24 toTick = tick + tickRange;\n        if (fromTick < _MIN_TICK) {\n            fromTick = _MIN_TICK;\n        }\n        if (toTick > _MAX_TICK) {\n            toTick = _MAX_TICK;\n        }\n\n        int24[] memory initTicks = new int24[](uint256(int256((toTick - fromTick + 1) / tickSpacing)));\n\n        uint256 counter = 0;\n        int16 pos = int16((fromTick / tickSpacing) >> 8);\n        int16 endPos = int16((toTick / tickSpacing) >> 8);\n        for (; pos <= endPos; pos++) {\n            uint256 bm = pool.tickBitmap(pos);\n\n            while (bm != 0) {\n                uint8 bit = _leastSignificantBit(bm);\n                bm ^= 1 << bit;\n                int24 extractedTick = ((int24(pos) << 8) | int24(uint24(bit))) * tickSpacing;\n                if (extractedTick >= fromTick && extractedTick <= toTick) {\n                    initTicks[counter++] = extractedTick;\n                }\n            }\n        }\n\n        ticks = new bytes[](counter);\n        for (uint256 i = 0; i < counter; i++) {\n            (\n                uint128 liquidityGross,\n                int128 liquidityNet,\n                uint256 feeGrowthOutside0X128,\n                uint256 feeGrowthOutside1X128\n                , // int56 tickCumulativeOutside,\n                , // secondsPerLiquidityOutsideX128\n                , // uint32 secondsOutside\n                , // init\n            ) = pool.ticks(initTicks[i]);\n\n            ticks[i] = abi.encodePacked(\n                liquidityGross,\n                liquidityNet,\n                feeGrowthOutside0X128,\n                feeGrowthOutside1X128,\n                // tickCumulativeOutside,\n                // secondsPerLiquidityOutsideX128,\n                // secondsOutside,\n                initTicks[i]\n            );\n        }\n    }\n\n    function _leastSignificantBit(uint256 x) private pure returns (uint8 r) {\n        require(x > 0, \"x is 0\");\n        x = x & (~x + 1);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n}\n"
    },
    "contracts/WombatPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/IMasterWombatV3.sol\";\n\ncontract WombatPoolHelper {\n    IMasterWombatV3 private constant _WOMBAT_MASTER_V3 = IMasterWombatV3(0x489833311676B566f888119c29bd997Dc6C95830);\n\n    function getAllPoolData() external view returns (address[] memory pools, address[][] memory poolTokens, address[] memory lpTokens, address[] memory underlyingTokens) {\n        // poolLength is actually the number of LP tokens tracked\n        uint256 lpTokenCount = _WOMBAT_MASTER_V3.poolLength();\n\n        // These two arrays will map all lp token addresses to their underlying token\n        lpTokens = new address[](lpTokenCount);\n        underlyingTokens = new address[](lpTokenCount);\n\n        // Create an array long enough to hold the maximum possible number pools\n        pools = new address[](lpTokenCount);\n\n        uint256 uniquePoolsSize;\n        for (uint256 i = 0; i < lpTokenCount; i++) {\n            (address lpToken,,,,,,,) = _WOMBAT_MASTER_V3.poolInfoV3(i);\n            lpTokens[i] = lpToken;\n            underlyingTokens[i] = IAsset(lpToken).underlyingToken();\n\n            address tokenPool = IAsset(lpToken).pool();\n\n            bool found = false;\n            for (uint256 k=0; k < uniquePoolsSize; k++) {\n                if (pools[k] == tokenPool) {\n                    found = true;\n                }\n            }\n            if (!found) {\n                pools[uniquePoolsSize++] = tokenPool;\n            }\n        }\n\n        // cut array size down to uniquePoolsSize\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(pools, uniquePoolsSize)\n        }\n\n        // The index of each token list in poolTokens will map to the pool ID tracked in poolsExtended\n        poolTokens = new address[][](uniquePoolsSize);\n        for (uint256 i = 0; i < uniquePoolsSize; i++) {\n            poolTokens[i] = IPool(pools[i]).getTokens();\n        }\n\n        return (pools, poolTokens, lpTokens, underlyingTokens);\n    }\n}\n\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}